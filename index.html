<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aligned D20 Dice</title>
<style>
body, #container {
  margin: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: transparent;
}

canvas {
    display: block;
    width: 300px;
    height: 300px;
    background-color: transparent;
}

button {
  margin-top: 10px;
  padding: 10px 20px;
  font-size: 16px;
  color: white;
  background: linear-gradient(135deg, #ff00cc, #3333ff, #00ffcc);
  border: none;
  border-radius: 8px;
  cursor: pointer;
  animation: glow 3s infinite linear;
}

button:hover {
  filter: brightness(1.2);
}

@keyframes glow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
</style>
</head>
<body>
<div id="container">
  <canvas id="diceCanvas"></canvas>
  <button id="rollButton">Roll the Dice!</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('diceCanvas'),
  alpha: true,
  antialias: true
});
renderer.setSize(300, 300);
renderer.setClearColor(0x000000, 0);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
camera.position.z = 5;

const light = new THREE.PointLight(0xffffff, 1, 100);
light.position.set(10, 10, 10);
scene.add(light);
const ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);

const geometry = new THREE.IcosahedronGeometry(2);
const material = new THREE.MeshStandardMaterial({
  color: 0x444444,
  roughness: 0.3,
  metalness: 0.8
});

const dice = new THREE.Mesh(geometry, material);
scene.add(dice);

const loader = new THREE.TextureLoader();
loader.load('https://i.imgur.com/ikm0qHk.jpg', (texture) => {
  material.map = texture;
  material.needsUpdate = true;
});

const rotations = [
  { x: 0, y: 0, z: 0 },
  { x: 0, y: 2 * Math.PI / 5, z: 0 },
  { x: 2 * Math.PI / 5, y: Math.PI / 5, z: 0 },
  { x: -2 * Math.PI / 5, y: 3 * Math.PI / 5, z: 0 },
  { x: Math.PI, y: 0, z: 0 },
  { x: 2 * Math.PI / 5, y: -Math.PI / 5, z: 0 },
  { x: -2 * Math.PI / 5, y: -3 * Math.PI / 5, z: 0 },
  { x: 0, y: -2 * Math.PI / 5, z: 0 },
  { x: -2 * Math.PI / 5, y: Math.PI / 5, z: 0 },
  { x: 2 * Math.PI / 5, y: 3 * Math.PI / 5, z: 0 },
  { x: 0, y: 4 * Math.PI / 5, z: 0 },
  { x: 4 * Math.PI / 5, y: 0, z: 0 },
  { x: -4 * Math.PI / 5, y: 2 * Math.PI / 5, z: 0 },
  { x: 4 * Math.PI / 5, y: 2 * Math.PI / 5, z: 0 },
  { x: -4 * Math.PI / 5, y: -2 * Math.PI / 5, z: 0 },
  { x: 4 * Math.PI / 5, y: -2 * Math.PI / 5, z: 0 },
  { x: 0, y: -4 * Math.PI / 5, z: 0 },
  { x: 2 * Math.PI / 5, y: -3 * Math.PI / 5, z: 0 },
  { x: -2 * Math.PI / 5, y: -Math.PI / 5, z: 0 },
  { x: -4 * Math.PI / 5, y: 0, z: 0 }
];

let rolling = false;
let targetRotation = { x: 0, y: 0, z: 0 };
let rollDuration = 2000;
let rollStartTime;

function animate(time) {
  requestAnimationFrame(animate);

  if (rolling) {
    const elapsedTime = time - rollStartTime;
    const progress = Math.min(elapsedTime / rollDuration, 1);

    if (progress < 1) {
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
      const easedProgress = easeOutCubic(progress);

      dice.rotation.x = targetRotation.x * easedProgress;
      dice.rotation.y = targetRotation.y * easedProgress;
      dice.rotation.z = targetRotation.z * easedProgress;
    } else {
      dice.rotation.x = targetRotation.x;
      dice.rotation.y = targetRotation.y;
      dice.rotation.z = targetRotation.z;
      rolling = false;
    }
  }

  renderer.render(scene, camera);
}
renderer.setClearColor(0x000000, 0); // The second parameter (alpha) is set to 0
// Enable shadow rendering
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// Make the light cast shadows
light.castShadow = true;

light.shadow.mapSize.width = 512;  // default is 512
light.shadow.mapSize.height = 512; // default is 512
light.shadow.camera.near = 0.5;    // default
light.shadow.camera.far = 500;     // default
light.shadow.radius = 8;           // Increase this value for more blur

// Add a plane to receive the shadow
const planeGeometry = new THREE.PlaneGeometry(10, 10);
const planeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xcccccc, 
    transparent: true, 
    opacity: 0 
});
const plane = new THREE.Mesh(planeGeometry, planeMaterial);
plane.rotation.x = -Math.PI / 2;
plane.position.y = -2;
plane.receiveShadow = true;
scene.add(plane);

document.getElementById('rollButton').addEventListener('click', () => {
  rolling = true;
  rollStartTime = performance.now();

  const randomIndex = Math.floor(Math.random() * rotations.length);
  targetRotation = rotations[randomIndex];

  targetRotation.x += Math.PI * 2 * Math.floor(Math.random() * 3);
  targetRotation.y += Math.PI * 2 * Math.floor(Math.random() * 3);
});
// Make the dice cast and receive shadows
dice.castShadow = true;
dice.receiveShadow = true;

animate();
</script>
</body>
</html>
